"""
Unit tests for post-exploitation modules.
"""

import pytest
import asyncio
from unittest.mock import Mock, AsyncMock, patch
from modules.postexploit.base_module import BaseModule
from modules.postexploit.module_registry import ModuleRegistry
from modules.postexploit.runner import ModuleRunner
from modules.postexploit.modules.sysinfo import SystemInfoModule
from modules.SSHSession import SSHSession


class DummyModule(BaseModule):
    """A dummy module for testing."""
    
    _name = "dummy"
    
    @property
    def name(self):
        return "dummy"
    
    @property
    def description(self):
        return "A dummy test module"
    
    @property
    def category(self):
        return "test"
    
    async def run(self):
        return {
            'success': True,
            'data': {'test': 'data'}
        }


@pytest.fixture
def mock_ssh_session():
    """Create a mock SSH session."""
    session = Mock(spec=SSHSession)
    session.get_remote_hostname = Mock(return_value="test-host")
    session.exec_command = AsyncMock(return_value="test output")
    session.exec_command_with_stderr = AsyncMock(return_value=("stdout", "stderr"))
    return session


class TestBaseModule:
    """Test the BaseModule abstract class."""
    
    @pytest.mark.asyncio
    async def test_base_module_instantiation(self, mock_ssh_session):
        """Test that we can instantiate a module."""
        module = DummyModule(mock_ssh_session)
        assert module.name == "dummy"
        assert module.description == "A dummy test module"
        assert module.category == "test"
    
    @pytest.mark.asyncio
    async def test_execute_command(self, mock_ssh_session):
        """Test command execution through the module."""
        module = DummyModule(mock_ssh_session)
        result = await module.execute_command("test command")
        assert result == "test output"
        mock_ssh_session.exec_command.assert_called_once_with("test command")
    
    @pytest.mark.asyncio
    async def test_execute_command_with_stderr(self, mock_ssh_session):
        """Test command execution with stderr."""
        module = DummyModule(mock_ssh_session)
        stdout, stderr = await module.execute_command_with_stderr("test command")
        assert stdout == "stdout"
        assert stderr == "stderr"
    
    @pytest.mark.asyncio
    async def test_get_hostname(self, mock_ssh_session):
        """Test getting the hostname."""
        module = DummyModule(mock_ssh_session)
        hostname = module.get_hostname()
        assert hostname == "test-host"
    
    @pytest.mark.asyncio
    async def test_module_run(self, mock_ssh_session):
        """Test running the module."""
        module = DummyModule(mock_ssh_session)
        result = await module.run()
        assert result['success'] is True
        assert 'data' in result


class TestModuleRegistry:
    """Test the ModuleRegistry."""
    
    def test_registry_initialization(self):
        """Test that we can initialize a registry."""
        registry = ModuleRegistry()
        assert isinstance(registry._modules, dict)
    
    def test_register_module(self):
        """Test registering a module."""
        registry = ModuleRegistry()
        registry.register(DummyModule)
        assert "dummy" in registry._modules
        assert registry._modules["dummy"] == DummyModule
    
    def test_get_module(self):
        """Test getting a registered module."""
        registry = ModuleRegistry()
        registry.register(DummyModule)
        module_class = registry.get_module("dummy")
        assert module_class == DummyModule
    
    def test_get_nonexistent_module(self):
        """Test getting a module that doesn't exist."""
        registry = ModuleRegistry()
        module_class = registry.get_module("nonexistent")
        assert module_class is None
    
    def test_list_modules(self):
        """Test listing all modules."""
        registry = ModuleRegistry()
        registry.register(DummyModule)
        modules = registry.list_modules()
        assert len(modules) > 0
        assert any(m['name'] == 'dummy' for m in modules)


class TestSystemInfoModule:
    """Test the SystemInfoModule."""
    
    @pytest.mark.asyncio
    async def test_sysinfo_module_properties(self, mock_ssh_session):
        """Test module properties."""
        module = SystemInfoModule(mock_ssh_session)
        assert module.name == "sysinfo"
        assert "system information" in module.description.lower()
        assert module.category == "recon"
    
    @pytest.mark.asyncio
    async def test_sysinfo_module_run_success(self, mock_ssh_session):
        """Test successful execution of sysinfo module."""
        # Mock various system commands
        def mock_exec_command(cmd):
            if "os-release" in cmd or "uname -a" in cmd:
                return asyncio.coroutine(lambda: "Linux test-host 5.10.0")()
            elif "uname -r" in cmd:
                return asyncio.coroutine(lambda: "5.10.0-1234")()
            elif "model name" in cmd:
                return asyncio.coroutine(lambda: "Intel Core i7")()
            elif "free -h" in cmd:
                return asyncio.coroutine(lambda: "Mem: 16Gi 4.0Gi 8.0Gi")()
            elif "ip addr" in cmd or "ifconfig" in cmd:
                return asyncio.coroutine(lambda: "eth0: 192.168.1.100")()
            elif "who" in cmd:
                return asyncio.coroutine(lambda: "root pts/0")()
            elif "uptime" in cmd:
                return asyncio.coroutine(lambda: "up 5 days")()
            return asyncio.coroutine(lambda: "")()
        
        mock_ssh_session.exec_command = mock_exec_command
        
        module = SystemInfoModule(mock_ssh_session)
        result = await module.run()
        
        assert result['success'] is True
        assert 'data' in result
        assert 'hostname' in result
        assert result['hostname'] == "test-host"
    
    @pytest.mark.asyncio
    async def test_sysinfo_module_run_partial_failure(self, mock_ssh_session):
        """Test sysinfo module with some commands failing."""
        def mock_exec_command_failing(cmd):
            if "os-release" in cmd:
                return asyncio.coroutine(lambda: "Linux test-host")()
            raise Exception("Command failed")
        
        mock_ssh_session.exec_command = mock_exec_command_failing
        
        module = SystemInfoModule(mock_ssh_session)
        result = await module.run()
        
        # Should still succeed even if some commands fail
        assert result['success'] is True
        assert 'data' in result


class TestModuleRunner:
    """Test the ModuleRunner."""
    
    @pytest.mark.asyncio
    async def test_runner_initialization(self):
        """Test runner initialization."""
        runner = ModuleRunner(output_dir="/tmp/test_output")
        assert runner.output_dir == "/tmp/test_output"
        assert isinstance(runner.registry, ModuleRegistry)
    
    @pytest.mark.asyncio
    async def test_run_module_success(self, mock_ssh_session):
        """Test running a module successfully."""
        runner = ModuleRunner(output_dir="/tmp/test_output")
        runner.registry.register(DummyModule)
        
        result = await runner.run_module("dummy", mock_ssh_session, save_results=False)
        
        assert result['success'] is True
        assert result['module'] == "dummy"
        assert 'timestamp' in result
    
    @pytest.mark.asyncio
    async def test_run_nonexistent_module(self, mock_ssh_session):
        """Test running a module that doesn't exist."""
        runner = ModuleRunner(output_dir="/tmp/test_output")
        
        result = await runner.run_module("nonexistent", mock_ssh_session, save_results=False)
        
        assert result['success'] is False
        assert 'error' in result
    
    @pytest.mark.asyncio
    async def test_list_available_modules(self):
        """Test listing available modules."""
        runner = ModuleRunner(output_dir="/tmp/test_output")
        runner.registry.register(DummyModule)
        
        modules = runner.list_available_modules()
        assert len(modules) > 0
        assert any(m['name'] == 'dummy' for m in modules)
