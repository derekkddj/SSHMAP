"""Module for running LinPEAS on the remote host."""
import os
import tempfile
import urllib.request
import asyncssh
from typing import Dict, Any
from modules.post_exploitation.base_module import BasePostExploitationModule
from modules.logger import sshmap_logger


class LinPEASModule(BasePostExploitationModule):
    """
    Executes LinPEAS (Linux Privilege Escalation Awesome Script) on the remote host.
    
    LinPEAS is a comprehensive script that searches for possible paths to escalate
    privileges on Linux/Unix systems.
    """
    
    # LinPEAS download URL - can be overridden if needed
    LINPEAS_URL = "https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh"
    # Timeout for LinPEAS execution in seconds (5 minutes)
    EXECUTION_TIMEOUT = 900
    
    @property
    def name(self) -> str:
        return "linpeas"
    
    @property
    def description(self) -> str:
        return "Execute LinPEAS script for privilege escalation enumeration"
    
    async def execute(self, ssh_session, output_dir: str) -> Dict[str, Any]:
        """Execute LinPEAS on the remote host."""
        local_linpeas_path = None
        try:
            hostname = ssh_session.get_remote_hostname()
            sshmap_logger.info(f"[{self.name}] Running LinPEAS on {hostname}")
            
            results = {
                "success": True,
                "hostname": hostname,
                "data": {},
                "error": None
            }
            
            # Check for local LinPEAS copy in wordlists directory
            wordlists_dir = "wordlists"
            if not os.path.exists(wordlists_dir):
                os.makedirs(wordlists_dir, exist_ok=True)
            
            persistent_linpeas_path = os.path.join(wordlists_dir, "linpeas.sh")
            local_linpeas_path = persistent_linpeas_path

            if os.path.exists(persistent_linpeas_path):
                sshmap_logger.info(f"[{self.name}] Using local LinPEAS copy from {persistent_linpeas_path}")
            else:
                # Download LinPEAS to the wordlists directory
                sshmap_logger.info(f"[{self.name}] Downloading LinPEAS to {persistent_linpeas_path}")
                try:
                    # Download with urllib
                    urllib.request.urlretrieve(self.LINPEAS_URL, persistent_linpeas_path)
                    sshmap_logger.debug(f"[{self.name}] LinPEAS downloaded successfully")
                except Exception as e:
                    raise Exception(f"Failed to download LinPEAS from {self.LINPEAS_URL}: {e}")
            
            # Create temporary directory on remote host
            temp_dir = "/tmp/.sshmap_linpeas"
            remote_linpeas_path = f"{temp_dir}/linpeas.sh"
            
            sshmap_logger.debug(f"[{self.name}] Creating temporary directory on {hostname}")
            await ssh_session.exec_command(f"mkdir -p {temp_dir}")
            
            # Upload LinPEAS to remote host using SCP
            sshmap_logger.info(f"[{self.name}] Uploading LinPEAS to {hostname}")
            try:
                await asyncssh.scp(local_linpeas_path, (ssh_session.connection, remote_linpeas_path))
                sshmap_logger.debug(f"[{self.name}] LinPEAS uploaded successfully")
            except Exception as e:
                raise Exception(f"Failed to upload LinPEAS to remote host: {e}")
            
            # Make LinPEAS executable
            sshmap_logger.debug(f"[{self.name}] Making LinPEAS executable")
            await ssh_session.exec_command(f"chmod +x {remote_linpeas_path}")
            
            # Execute LinPEAS
            sshmap_logger.info(f"[{self.name}] Executing LinPEAS (this may take several minutes)")
            # Check if timeout command is available, then use it
            check_timeout_cmd = "command -v timeout >/dev/null 2>&1 && echo 'HAS_TIMEOUT' || echo 'NO_TIMEOUT'"
            has_timeout = await ssh_session.exec_command(check_timeout_cmd)
            
            # Run with -a flag for all checks (comprehensive)
            if "HAS_TIMEOUT" in has_timeout:
                exec_cmd = f"cd {temp_dir} && timeout {self.EXECUTION_TIMEOUT} bash ./linpeas.sh -a 2>&1 || echo 'LinPEAS execution completed or timed out'"
            else:
                # Without timeout, just run the script (may take longer)
                sshmap_logger.warning(f"[{self.name}] timeout command not available, running without timeout")
                exec_cmd = f"cd {temp_dir} && bash ./linpeas.sh -a 2>&1 || echo 'LinPEAS execution completed'"
            
            linpeas_output = await ssh_session.exec_command(exec_cmd)
            
            results["data"]["output"] = linpeas_output
            
            # Save output to file
            output_file = os.path.join(output_dir, f"{hostname}_linpeas.txt")
            with open(output_file, "w") as f:
                f.write(f"LinPEAS Output\n")
                f.write(f"Host: {hostname}\n")
                f.write(f"{'='*80}\n\n")
                f.write(linpeas_output)
            
            # Cleanup remote files
            sshmap_logger.debug(f"[{self.name}] Cleaning up remote temporary files")
            await ssh_session.exec_command(f"rm -rf {temp_dir}")
            
            sshmap_logger.display(f"[{self.name}] LinPEAS output saved to {output_file}")
            
            return results
            
        except Exception as e:
            sshmap_logger.error(f"[{self.name}] Failed to execute LinPEAS: {e}")
            
            # Try to cleanup even on error
            try:
                await ssh_session.exec_command(f"rm -rf /tmp/.sshmap_linpeas")
            except:
                pass
            
            return {
                "success": False,
                "hostname": hostname if 'hostname' in locals() else "unknown",
                "data": None,
                "error": str(e)
            }
        finally:
            # We preserve the local LinPEAS file in wordlists for future use
            pass
