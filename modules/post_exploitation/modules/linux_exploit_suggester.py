"""Module for running Linux Exploit Suggester on the remote host."""
import os
import urllib.request
import asyncssh
from typing import Dict, Any
from modules.post_exploitation.base_module import BasePostExploitationModule
from modules.logger import sshmap_logger


class LinuxExploitSuggesterModule(BasePostExploitationModule):
    """
    Executes Linux Exploit Suggester on the remote host.
    
    Linux Exploit Suggester is a Perl script that checks for kernel vulnerabilities
    and suggests potential local privilege escalation exploits.
    """
    
    # Linux Exploit Suggester download URL
    LES_URL = "https://raw.githubusercontent.com/The-Z-Labs/linux-exploit-suggester/master/linux-exploit-suggester.sh"
    # Timeout for LES execution in seconds (2 minutes)
    EXECUTION_TIMEOUT = 120
    
    @property
    def name(self) -> str:
        return "linux_exploit_suggester"
    
    @property
    def description(self) -> str:
        return "Execute Linux Exploit Suggester to identify kernel vulnerabilities"
    
    async def execute(self, ssh_session, output_dir: str) -> Dict[str, Any]:
        """Execute Linux Exploit Suggester on the remote host."""
        local_les_path = None
        try:
            hostname = ssh_session.get_remote_hostname()
            sshmap_logger.info(f"[{self.name}] Running Linux Exploit Suggester on {hostname}")
            
            results = {
                "success": True,
                "hostname": hostname,
                "data": {},
                "error": None
            }
            
            # Check for local Linux Exploit Suggester copy in wordlists directory
            wordlists_dir = "wordlists"
            if not os.path.exists(wordlists_dir):
                os.makedirs(wordlists_dir, exist_ok=True)

            persistent_les_path = os.path.join(wordlists_dir, "linux-exploit-suggester.sh")
            local_les_path = persistent_les_path

            if os.path.exists(persistent_les_path):
                sshmap_logger.info(f"[{self.name}] Using local Linux Exploit Suggester copy from {persistent_les_path}")
            else:
                # Download Linux Exploit Suggester to the wordlists directory
                sshmap_logger.info(f"[{self.name}] Downloading Linux Exploit Suggester to {persistent_les_path}")

                try:
                    # Download with urllib
                    urllib.request.urlretrieve(self.LES_URL, persistent_les_path)
                    sshmap_logger.debug(f"[{self.name}] Linux Exploit Suggester downloaded successfully")
                except Exception as e:
                    raise Exception(f"Failed to download Linux Exploit Suggester from {self.LES_URL}: {e}")
            
            # Create temporary directory on remote host
            temp_dir = "/tmp/.sshmap_les"
            remote_les_path = f"{temp_dir}/linux-exploit-suggester.sh"
            
            sshmap_logger.debug(f"[{self.name}] Creating temporary directory on {hostname}")
            await ssh_session.exec_command(f"mkdir -p {temp_dir}")
            
            # Upload Linux Exploit Suggester to remote host using SCP
            sshmap_logger.info(f"[{self.name}] Uploading Linux Exploit Suggester to {hostname}")
            try:
                await asyncssh.scp(local_les_path, (ssh_session.connection, remote_les_path))
                sshmap_logger.debug(f"[{self.name}] Linux Exploit Suggester uploaded successfully")
            except Exception as e:
                raise Exception(f"Failed to upload Linux Exploit Suggester to remote host: {e}")
            
            # Make Linux Exploit Suggester executable
            sshmap_logger.debug(f"[{self.name}] Making Linux Exploit Suggester executable")
            await ssh_session.exec_command(f"chmod +x {remote_les_path}")
            
            # Execute Linux Exploit Suggester
            sshmap_logger.info(f"[{self.name}] Executing Linux Exploit Suggester")
            # Check if timeout command is available
            check_timeout_cmd = "command -v timeout >/dev/null 2>&1 && echo 'HAS_TIMEOUT' || echo 'NO_TIMEOUT'"
            has_timeout = await ssh_session.exec_command(check_timeout_cmd)
            
            # Execute with timeout if available
            if "HAS_TIMEOUT" in has_timeout:
                exec_cmd = f"cd {temp_dir} && timeout {self.EXECUTION_TIMEOUT} ./linux-exploit-suggester.sh 2>&1 || echo 'LES execution completed or timed out'"
            else:
                # Without timeout, just run the script
                sshmap_logger.warning(f"[{self.name}] timeout command not available, running without timeout")
                exec_cmd = f"cd {temp_dir} && ./linux-exploit-suggester.sh 2>&1 || echo 'LES execution completed'"
            
            les_output = await ssh_session.exec_command(exec_cmd)
            
            results["data"]["output"] = les_output
            
            # Parse output to extract vulnerability information
            vulnerabilities = self._parse_vulnerabilities(les_output)
            if vulnerabilities:
                results["data"]["vulnerabilities"] = vulnerabilities
                sshmap_logger.info(f"[{self.name}] Found {len(vulnerabilities)} potential vulnerabilities")
            
            # Save output to file
            output_file = os.path.join(output_dir, f"{hostname}_linux_exploit_suggester.txt")
            with open(output_file, "w") as f:
                f.write("Linux Exploit Suggester Output\n")
                f.write(f"Host: {hostname}\n")
                f.write(f"{'='*80}\n\n")
                f.write(les_output)
            
            # Cleanup remote files
            sshmap_logger.debug(f"[{self.name}] Cleaning up remote temporary files")
            await ssh_session.exec_command(f"rm -rf {temp_dir}")
            
            sshmap_logger.display(f"[{self.name}] Linux Exploit Suggester output saved to {output_file}")
            
            return results
            
        except Exception as e:
            sshmap_logger.error(f"[{self.name}] Failed to execute Linux Exploit Suggester: {e}")
            
            # Try to cleanup even on error
            try:
                await ssh_session.exec_command("rm -rf /tmp/.sshmap_les")
            except Exception:
                pass
            
            return {
                "success": False,
                "hostname": hostname if 'hostname' in locals() else "unknown",
                "data": None,
                "error": str(e)
            }
        finally:
            # We preserve the local Linux Exploit Suggester file in wordlists for future use
            pass
    
    def _parse_vulnerabilities(self, output: str) -> list:
        """Parse the output to extract vulnerability information."""
        vulnerabilities = []
        lines = output.split('\n')
        
        # Look for lines that indicate vulnerabilities
        # Format varies but typically includes CVE numbers or exploit names
        for line in lines:
            line = line.strip()
            # Look for lines with CVE numbers or vulnerability indicators
            if any(keyword in line.lower() for keyword in ['cve-', 'exploit', 'vulnerable', '[+]', 'possible']):
                if line and not line.startswith('#') and len(line) > 10:
                    vulnerabilities.append(line)
        
        return vulnerabilities
