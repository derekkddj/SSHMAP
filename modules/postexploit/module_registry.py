"""
Module registry for discovering and managing post-exploitation modules.
"""

import os
import importlib
import inspect
from typing import Dict, List, Type, Optional
from .base_module import BaseModule
from modules.logger import sshmap_logger


class ModuleRegistry:
    """
    Registry for post-exploitation modules.
    
    Automatically discovers and loads modules from the modules directory.
    Provides methods to list, get, and run modules.
    """
    
    def __init__(self):
        """Initialize the module registry."""
        self._modules: Dict[str, Type[BaseModule]] = {}
        self.logger = sshmap_logger
    
    def register(self, module_class: Type[BaseModule]):
        """
        Register a module class.
        
        Args:
            module_class: A class that inherits from BaseModule
            
        Raises:
            ValueError: If the class is not a valid BaseModule subclass
        """
        if not issubclass(module_class, BaseModule):
            raise ValueError(f"{module_class.__name__} must inherit from BaseModule")
        
        # Create a temporary instance to get the name
        # We'll use a dummy ssh_session for this
        try:
            # Get the name from class attributes if available, otherwise skip
            if hasattr(module_class, '_name'):
                name = module_class._name
            else:
                # We'll register it without instantiation, get name later
                name = module_class.__name__.lower().replace('module', '')
            
            self._modules[name] = module_class
            self.logger.debug(f"Registered post-exploitation module: {name}")
        except Exception as e:
            self.logger.warning(f"Could not register module {module_class.__name__}: {e}")
    
    def discover_modules(self, modules_dir: str = None):
        """
        Automatically discover and load all modules from a directory.
        
        Args:
            modules_dir: Directory containing module files. If None, uses default.
        """
        if modules_dir is None:
            # Default to the 'modules' subdirectory in postexploit
            current_dir = os.path.dirname(os.path.abspath(__file__))
            modules_dir = os.path.join(current_dir, 'modules')
        
        if not os.path.exists(modules_dir):
            self.logger.debug(f"Modules directory {modules_dir} does not exist yet")
            return
        
        # Scan for Python files
        for filename in os.listdir(modules_dir):
            if filename.endswith('.py') and not filename.startswith('_'):
                module_name = filename[:-3]
                try:
                    # Import the module
                    module_path = f"modules.postexploit.modules.{module_name}"
                    mod = importlib.import_module(module_path)
                    
                    # Find all BaseModule subclasses in the module
                    for item_name in dir(mod):
                        item = getattr(mod, item_name)
                        if (inspect.isclass(item) and 
                            issubclass(item, BaseModule) and 
                            item is not BaseModule):
                            self.register(item)
                
                except Exception as e:
                    self.logger.warning(f"Failed to load module {module_name}: {e}")
    
    def get_module(self, name: str) -> Optional[Type[BaseModule]]:
        """
        Get a module class by name.
        
        Args:
            name: The name of the module
            
        Returns:
            The module class, or None if not found
        """
        return self._modules.get(name)
    
    def list_modules(self) -> List[Dict[str, str]]:
        """
        List all registered modules with their information.
        
        Returns:
            List of dicts containing module name, description, and category
        """
        modules_info = []
        for name, module_class in self._modules.items():
            # We need to instantiate to get description, but we'll handle this carefully
            try:
                # Try to get class-level attributes if they exist
                info = {
                    'name': name,
                    'class': module_class.__name__,
                    'description': getattr(module_class, '__doc__', 'No description available'),
                    'category': 'general'
                }
                modules_info.append(info)
            except Exception as e:
                self.logger.warning(f"Could not get info for module {name}: {e}")
        
        return modules_info
    
    def get_modules_by_category(self, category: str) -> List[str]:
        """
        Get all modules in a specific category.
        
        Args:
            category: The category to filter by
            
        Returns:
            List of module names in that category
        """
        matching_modules = []
        for name in self._modules.keys():
            # This is a simplified version - in practice you'd instantiate or check metadata
            matching_modules.append(name)
        return matching_modules


# Global registry instance
registry = ModuleRegistry()
