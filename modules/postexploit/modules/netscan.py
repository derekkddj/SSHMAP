"""
Network scanner module.

Discover other hosts on the local network from the compromised host.
"""

from typing import Dict, Any
from modules.postexploit.base_module import BaseModule


class NetworkScanModule(BaseModule):
    """Scan local network for other hosts."""
    
    _name = "netscan"
    
    def __init__(self, ssh_session, scan_ports: list = None):
        """
        Initialize the network scan module.
        
        Args:
            ssh_session: SSH session to use
            scan_ports: List of ports to scan (default: [22, 80, 443])
        """
        super().__init__(ssh_session)
        self.scan_ports = scan_ports or [22, 80, 443, 445, 3389]
    
    @property
    def name(self) -> str:
        return "netscan"
    
    @property
    def description(self) -> str:
        return "Scan local network for other hosts and open ports"
    
    @property
    def category(self) -> str:
        return "recon"
    
    async def run(self) -> Dict[str, Any]:
        """
        Scan the local network from the remote host.
        
        Returns:
            Dictionary with scan results
        """
        hostname = self.get_hostname()
        self.log_info(f"Starting network scan from {hostname}")
        
        try:
            results = {
                'success': True,
                'hostname': hostname,
                'data': {
                    'local_interfaces': [],
                    'discovered_hosts': [],
                    'arp_table': None
                }
            }
            
            # Get local network interfaces
            try:
                ip_output = await self.execute_command("ip -o addr show | grep -E 'inet ' | awk '{print $2, $4}'")
                interfaces = []
                for line in ip_output.strip().split('\n'):
                    if line:
                        parts = line.split()
                        if len(parts) >= 2:
                            interfaces.append({
                                'interface': parts[0],
                                'cidr': parts[1]
                            })
                results['data']['local_interfaces'] = interfaces
                self.log_info(f"Found {len(interfaces)} network interfaces")
            except Exception as e:
                self.log_warning(f"Could not get network interfaces: {e}")
            
            # Get ARP table (shows recently communicated hosts)
            try:
                arp_output = await self.execute_command("ip neigh show 2>/dev/null || arp -a")
                results['data']['arp_table'] = arp_output.strip()
                
                # Parse ARP entries to get discovered hosts
                discovered = []
                for line in arp_output.strip().split('\n'):
                    if line and ('REACHABLE' in line or 'STALE' in line or 'DELAY' in line):
                        parts = line.split()
                        if len(parts) > 0:
                            ip = parts[0]
                            discovered.append(ip)
                
                if discovered:
                    self.log_info(f"Found {len(discovered)} hosts in ARP table")
                    results['data']['discovered_hosts'] = discovered
            except Exception as e:
                self.log_warning(f"Could not get ARP table: {e}")
            
            # Check for common network scanning tools
            tools_available = {}
            for tool in ['nmap', 'nc', 'ping', 'telnet']:
                try:
                    check = await self.execute_command(f"which {tool} 2>/dev/null")
                    tools_available[tool] = bool(check.strip())
                except:
                    tools_available[tool] = False
            
            results['data']['scanning_tools'] = tools_available
            self.log_info(f"Available scanning tools: {[k for k, v in tools_available.items() if v]}")
            
            # Try a simple ping sweep if ping is available
            if tools_available.get('ping', False) and interfaces:
                try:
                    # Get the first /24 subnet
                    first_interface = interfaces[0]['cidr']
                    # Extract network (simple approach for /24)
                    ip_part = first_interface.split('/')[0]
                    network_parts = ip_part.split('.')
                    if len(network_parts) >= 3:
                        subnet_base = f"{network_parts[0]}.{network_parts[1]}.{network_parts[2]}"
                        self.log_info(f"Performing ping sweep on {subnet_base}.0/24")
                        
                        # Quick ping sweep (just a few hosts for demonstration)
                        ping_results = []
                        ping_cmd = f"for i in {{1..10}}; do ping -c 1 -W 1 {subnet_base}.$i 2>/dev/null && echo \"{subnet_base}.$i is up\"; done"
                        ping_output = await self.execute_command(ping_cmd)
                        
                        for line in ping_output.strip().split('\n'):
                            if 'is up' in line:
                                ip = line.split()[0]
                                if ip not in discovered:
                                    ping_results.append(ip)
                        
                        if ping_results:
                            results['data']['ping_sweep_results'] = ping_results
                            self.log_info(f"Ping sweep found {len(ping_results)} additional hosts")
                except Exception as e:
                    self.log_warning(f"Ping sweep failed: {e}")
            
            self.log_success(f"Network scan complete from {hostname}")
            return results
            
        except Exception as e:
            self.log_error(f"Network scan failed: {e}")
            return {
                'success': False,
                'hostname': hostname,
                'error': str(e),
                'data': {}
            }
