"""
Post-exploitation module runner.

Provides utilities to execute post-exploitation modules on SSH sessions.
"""

import json
import os
from typing import Dict, Any, List, Optional
from datetime import datetime
from modules.SSHSession import SSHSession
from modules.logger import sshmap_logger
from .module_registry import ModuleRegistry
from .base_module import BaseModule


class ModuleRunner:
    """
    Runner for executing post-exploitation modules.
    """
    
    def __init__(self, output_dir: str = "output/postexploit"):
        """
        Initialize the module runner.
        
        Args:
            output_dir: Directory to save module results
        """
        self.output_dir = output_dir
        self.logger = sshmap_logger
        self.registry = ModuleRegistry()
        
        # Discover available modules
        self.registry.discover_modules()
    
    async def run_module(
        self, 
        module_name: str, 
        ssh_session: SSHSession, 
        save_results: bool = True,
        **module_kwargs
    ) -> Dict[str, Any]:
        """
        Run a specific module on an SSH session.
        
        Args:
            module_name: Name of the module to run
            ssh_session: Active SSH session
            save_results: Whether to save results to disk
            **module_kwargs: Additional arguments to pass to module constructor
            
        Returns:
            Dictionary containing module results
        """
        module_class = self.registry.get_module(module_name)
        if not module_class:
            self.logger.error(f"Module '{module_name}' not found")
            return {
                'success': False,
                'error': f"Module '{module_name}' not found",
                'module': module_name
            }
        
        try:
            # Instantiate the module
            module = module_class(ssh_session, **module_kwargs)
            
            self.logger.info(f"Running module '{module_name}' on {ssh_session.get_remote_hostname()}")
            
            # Run the module
            results = await module.run()
            results['module'] = module_name
            results['timestamp'] = datetime.now().isoformat()
            
            # Save results if requested
            if save_results and results.get('success', False):
                await self._save_results(results)
            
            return results
            
        except Exception as e:
            self.logger.error(f"Error running module '{module_name}': {e}")
            return {
                'success': False,
                'error': str(e),
                'module': module_name,
                'hostname': ssh_session.get_remote_hostname()
            }
    
    async def run_multiple_modules(
        self,
        module_names: List[str],
        ssh_session: SSHSession,
        save_results: bool = True
    ) -> Dict[str, Any]:
        """
        Run multiple modules sequentially on an SSH session.
        
        Args:
            module_names: List of module names to run
            ssh_session: Active SSH session
            save_results: Whether to save results to disk
            
        Returns:
            Dictionary containing all module results
        """
        hostname = ssh_session.get_remote_hostname()
        self.logger.info(f"Running {len(module_names)} modules on {hostname}")
        
        all_results = {
            'hostname': hostname,
            'timestamp': datetime.now().isoformat(),
            'modules': {},
            'summary': {
                'total': len(module_names),
                'successful': 0,
                'failed': 0
            }
        }
        
        for module_name in module_names:
            result = await self.run_module(module_name, ssh_session, save_results=False)
            all_results['modules'][module_name] = result
            
            if result.get('success', False):
                all_results['summary']['successful'] += 1
            else:
                all_results['summary']['failed'] += 1
        
        # Save combined results
        if save_results:
            await self._save_results(all_results, suffix='_combined')
        
        self.logger.success(
            f"Completed {len(module_names)} modules on {hostname}: "
            f"{all_results['summary']['successful']} successful, "
            f"{all_results['summary']['failed']} failed"
        )
        
        return all_results
    
    async def _save_results(self, results: Dict[str, Any], suffix: str = ''):
        """
        Save module results to disk.
        
        Args:
            results: Results dictionary to save
            suffix: Optional suffix for filename
        """
        try:
            hostname = results.get('hostname', 'unknown')
            module_name = results.get('module', 'unknown')
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            
            # Create output directory
            host_dir = os.path.join(self.output_dir, hostname)
            os.makedirs(host_dir, exist_ok=True)
            
            # Save as JSON
            filename = f"{timestamp}_{module_name}{suffix}.json"
            filepath = os.path.join(host_dir, filename)
            
            with open(filepath, 'w') as f:
                json.dump(results, f, indent=2)
            
            self.logger.debug(f"Saved results to {filepath}")
            
        except Exception as e:
            self.logger.warning(f"Failed to save results: {e}")
    
    def list_available_modules(self) -> List[Dict[str, str]]:
        """
        Get list of all available modules.
        
        Returns:
            List of module information dictionaries
        """
        return self.registry.list_modules()


# Global runner instance
runner = ModuleRunner()
